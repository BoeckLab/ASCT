---
title: "ASCT.anaylsis_v0"
author: "Alex"
date: "2025-03-28"
output: html_document
---

Author: Alexander Jovanovic
Pulmonary Infection Biology
Department of Biomedicine
University Hospital Basel
Hebelstrasse 20 
4031 Basel
SWITZERLAND


# -----  ASCT single cell analysis ----

This script performs single-cell analysis of antibiotic response in Mycobacterium abscessus. It integrates ilastik-based morphology and viability classification with MATLAB tracking outputs,computes pseudo-growth features, interpolates live cell fractions, calculates area under time-kill curves, generates results tables and visualizes the data in a single figure.


# 0. Defining paths and variables
```{r}
info.wd <- getwd()


# List all directories in the current working directory
info.list.of.dir <- normalizePath(list.dirs(path = ".", full.names = TRUE, recursive = FALSE))

# finding paths to directories that contain  e.g "_Metadata" in their name
info.metadata.dir <- info.list.of.dir[grepl("_Metadata", basename(info.list.of.dir))]
info.moc.dir <- info.list.of.dir[grepl("moc", basename(info.list.of.dir))]
info.poc.dir <- info.list.of.dir[grepl("poc", basename(info.list.of.dir))]
info.matlab.trk.dir <- info.list.of.dir[grepl("Tracking_labeloid", basename(info.list.of.dir))]


# Defining the experiment ID and well based on prefex of directoreis
info.expID <-  strsplit(basename(normalizePath(info.moc.dir)), "_")[[1]][1]
info.well <- strsplit(basename(normalizePath(info.moc.dir)), "_")[[1]][2]


info.plot.xaxis.time.scale <- c(0,12,24,36,48,60,72)
```



# 1. Loading R libraries
```{r}
# Data wrangling
library(tidyverse)
library(dplyr)
library(reshape2)

# Visualization
library(ggplot2)
library(ggpubr)
library(ggprism)
library(ggrepel)
library(ggpubr)
library(ggforce)
library(wesanderson)
library(tibble)
library(patchwork)
library(grid)



```


# 2. Load Metadata
```{r}

# Loop through each CSV file and load it one by one

  
  
   metaData.filenames <- list.files(path = info.metadata.dir,
                                   pattern = "*.csv",
                                   full.names = FALSE)
  #setting path to where all the csv files due to be processed are
  setwd(info.metadata.dir)
  
  
  metaData.file.list <- lapply(metaData.filenames,
                               read.delim2)
  
  #Naming the elements of my list with the vector list of my file names
  Exp.Names <- gsub(".csv","",metaData.filenames)
  names(metaData.file.list ) <- Exp.Names
  
  #Creating the empty Metadata (MD) dataframe # HERE
  ASCT.metadata.df  <- bind_rows(metaData.file.list, .id = "ExpFile_Well_Field")
  ASCT.metadata.df  <- ASCT.metadata.df  %>% select_if(~!all(is.na(.)))
  ASCT.metadata.df $ExpFile_Well_Field <- stringr::str_replace_all(ASCT.metadata.df $ExpFile_Well_Field, "_Metadata","")
  
  #Houskeeping
  rm(metaData.file.list,
     metaData.filenames)
  
  #creating appropriate colunm can colunm labels
  ASCT.metadata.df  <- ASCT.metadata.df  %>% separate(sep..,
                              sep =",",
                              c("TimeStamp", "Time [s]"))

  
  ASCT.metadata.df  <- ASCT.metadata.df  %>%
    dplyr::mutate(Time_sec = `Time [s]` )%>%
    dplyr::mutate(timestep = TimeStamp) %>%
    select(-`Time [s]`,
           -TimeStamp)
  
  ASCT.metadata.df $timestep <- stringr::str_replace_all(ASCT.metadata.df $timestep, "TimeStamp ","")
  
  #changing value type
  ASCT.metadata.df $Time_sec <- as.numeric(ASCT.metadata.df $Time_sec)
  ASCT.metadata.df $timestep <- as.numeric(ASCT.metadata.df $timestep)
  

  
  ASCT.metadata.df $Time_sec <- round(ASCT.metadata.df $Time_sec, digits = 2)
  
  
  # The code below will account for instances where when have two concatenated time lapses and we need MD of the timeframe of the first loopA to be added to the rest of the MD of LoopBs

  
  ASCT.metadata.df  <- ASCT.metadata.df  %>%
    drop_na()%>%
    group_by(ExpFile_Well_Field)%>%
    dplyr::mutate(Time_frame_Order = 1,
           Time_frame_Order = cumsum(Time_frame_Order))
  

  
  ASCT.metadata.df <- ASCT.metadata.df  %>%
    group_by(ExpFile_Well_Field)%>%
    dplyr::mutate(new_time_sec2 = if_else(timestep != Time_frame_Order, 
                                   Time_sec + last(Time_sec[timestep == Time_frame_Order]), 
                                   Time_sec))
  
  
  ASCT.metadata.df  <-  ASCT.metadata.df  %>%
    dplyr::mutate(Time_sec = new_time_sec2,
           timestep = Time_frame_Order)%>%
    select(ExpFile_Well_Field,
           Time_sec,
           timestep)
  
  
  

  
  ASCT.metadata.df  <- ASCT.metadata.df  %>%
    drop_na()%>% # removing rows with NAs
    dplyr::mutate(timestep = timestep-1) #Replicating output generated by Ilastik where timestep stars from 0
  
  
  
  # Splitting the colum ExpFile_Well_Field to 3 colunms. Allows us to merge with MS.res.df
  ASCT.metadata.df  <- tidyr::separate(ASCT.metadata.df , col = ExpFile_Well_Field,
                    into = c("ExpFile",
                             "Well_coordinate",
                             "Field"),
                    sep="_")
  
  ASCT.metadata.df  <- ASCT.metadata.df  %>%
    dplyr::select(Well_coordinate,
                  Field,
                  Time_sec,
                  timestep)
  
  # # Mean time  per well per timestep / image frame
  ASCT.metadata.df  <- ASCT.metadata.df  %>%
    dplyr::ungroup()%>%
    dplyr::group_by(Well_coordinate,
                    timestep)%>%
    dplyr::mutate(Time_Hrs = mean(Time_sec)/3600) # converting to hours
  
  # Removing duplicate times. We expect the same number of real time (Time_Hrs) as we have timesteps
  ASCT.metadata.df  <- ASCT.metadata.df  %>%
    dplyr::ungroup()%>%
    select(Well_coordinate,
           timestep,
           Time_Hrs)%>%
    distinct()
 
  
# Houskeeping
rm(Exp.Names)

setwd(info.wd)
```

# 3. Load Morphology Object Classification
```{r}
#Creacting vector with the list of file names
  OC.filenames <- list.files(path = info.moc.dir,
                             pattern = "*.csv",
                             full.names = FALSE)
  
  #setting path to where all the csv files due to be processed are
  setwd(info.moc.dir)
 
  OC.file.list <- lapply(OC.filenames,
                         read.csv)
  
  
  
  #Naming the elements of my list with the vector list of my file names
  Exp.Names <- gsub(".csv","",OC.filenames)
  names(OC.file.list)<- Exp.Names
  
  #Irrespective of the number of rows bind all the elemtents of my list using a unique identifier "well_coord" which is based on the name of each element of the list 
  
ASCT.moc.df <- bind_rows(OC.file.list, .id = "Ilastik_Classification_ExpFile_Well_Field")
  
ASCT.moc.df <- tidyr::separate(ASCT.moc.df, col = Ilastik_Classification_ExpFile_Well_Field,
                    into = c("Ilastik",
                             "Classification",
                             "ExpFile",
                             "Well_coordinate",
                             "Field"),
                    sep="_")
  
ASCT.moc.df <- ASCT.moc.df %>%
    dplyr::mutate(MOC.Predicted.Class = Predicted.Class)%>%

    dplyr::select(-Ilastik,
                  -Classification,
                  -Predicted.Class,
                  -Mean.Intensity)
  

 
ASCT.moc.df <- ASCT.moc.df %>%
    dplyr::mutate(Field = as.numeric(gsub("p","",Field)))%>%
  select_if(~!all(is.na(.))) 
  
  
  # House keeping
  rm(OC.file.list,
     OC.filenames,
     Exp.Names)

  setwd(info.wd)
```


# 4. Load Viability Object Classification

```{r}

 
  #Creacting vector with the list of file names
  OC.filenames <- list.files(path = info.poc.dir,
                             pattern = "*.csv",
                             full.names = FALSE)
  
  #setting path to where all the csv files due to be processed are
  setwd(info.poc.dir)
  
  OC.file.list <- lapply(OC.filenames,
                         read.csv)
  
  
  #Naming the elements of my list with the vector list of my file names
  Exp.Names <- gsub(".csv","",OC.filenames)
  names(OC.file.list)<- Exp.Names
  
  #Irrespective of the number of rows bind all the elemtents of my list using a unique identifier "well_coord" which is based on the name of each element of the list 
  ASCT.poc.df <- bind_rows(OC.file.list, .id = "Ilastik_Classification_ExpFile_Well_Field")
  
  ASCT.poc.df <- tidyr::separate(ASCT.poc.df, col = Ilastik_Classification_ExpFile_Well_Field,
                    into = c("Ilastik",
                             "Classification",
                             "ExpFile",
                             "Well_coordinate",
                             "Field"),
                    sep="_")
  
  ASCT.poc.df <- ASCT.poc.df %>%
    dplyr::mutate(POC.Predicted.Class = Predicted.Class)%>%
    dplyr::mutate(Mean.IntensityBaSic = Mean.Intensity)%>%
    dplyr::select(-Ilastik,
                  -Classification,
                  -Predicted.Class,
                  -Mean.Intensity)

 
  ASCT.poc.df <- ASCT.poc.df %>%
    dplyr::mutate(Field = as.numeric(gsub("p","",Field)))%>%
  select_if(~!all(is.na(.))) 
  
  
  #House keeping
  rm(OC.file.list,
     OC.filenames,
     Exp.Names,
     trk.filename)
```

# 5. psudoGrowth assessment
## 5.1 Total area of bacteria and total nuber of single cell bacteria
```{r}

# Total Object Area

psudoGrowth.totObjArea.df <- ASCT.moc.df %>%
  dplyr::ungroup()%>%
  dplyr::select(ExpFile,
                Well_coordinate,
                timestep,
                Size.in.pixels,
                MOC.Predicted.Class)%>%
  filter(MOC.Predicted.Class != "FC")%>%
  dplyr::group_by( ExpFile ,
                    Well_coordinate     ,
                         timestep)%>%
  dplyr::mutate(psudoGrowth_totObjArea = sum(Size.in.pixels))%>%
  dplyr::ungroup()%>%
  dplyr::select(-Size.in.pixels,
                -MOC.Predicted.Class)%>%
  dplyr::distinct()

# Total Object Number

#--- Total number (N) of SC
psudoGrowth.totNSC.df <- ASCT.moc.df %>%
  dplyr::select(ExpFile,
                Well_coordinate,
                timestep,
                MOC.Predicted.Class)%>%
  dplyr::filter(MOC.Predicted.Class == "SC" )%>%
  dplyr::mutate(Objects = 1)%>%
  dplyr::group_by( Well_coordinate,
                   timestep)%>%
  dplyr:: mutate(psudoGrowth_nSC = sum(Objects))%>%
  dplyr::ungroup()%>%
  dplyr::select(ExpFile,
                Well_coordinate,
                timestep,
                psudoGrowth_nSC)%>%
  dplyr::distinct()


#--- Total number (N) of SC and VS
psudoGrowth.totNSCVS.df <- ASCT.moc.df %>%
  dplyr::select(ExpFile,
                Well_coordinate,
                timestep,
                MOC.Predicted.Class)%>%
  dplyr::filter(MOC.Predicted.Class == "SC"  | MOC.Predicted.Class == "VS" )%>%
  dplyr::mutate(Objects = 1)%>%
  dplyr::group_by( Well_coordinate,
                   timestep)%>%
  dplyr:: mutate(psudoGrowth_nSC.VS = sum(Objects))%>%
  dplyr::ungroup()%>%
  dplyr::select(ExpFile,
                Well_coordinate,
                timestep,
                psudoGrowth_nSC.VS)%>%
  dplyr::distinct()



# Merge and reshape the dataframe 

psudoGrowth.df <- left_join(psudoGrowth.totObjArea.df,
                  psudoGrowth.totNSC.df)

psudoGrowth.df <- left_join(psudoGrowth.df ,
                  psudoGrowth.totNSCVS.df)



psudoGrowth.df <- left_join(
                       psudoGrowth.df,
                       ASCT.metadata.df)

psudoGrowth.df <- psudoGrowth.df  %>%
  select(ExpFile,
         Well_coordinate,
         Well_coordinate,
         timestep,
         Time_Hrs,
       psudoGrowth_totObjArea,
       psudoGrowth_nSC,
       psudoGrowth_nSC.VS)

#Houskeeping 
rm(psudoGrowth.totObjArea.df,
   psudoGrowth.totNSC.df,
   psudoGrowth.totNSCVS.df)
```

## 5.2 Interpolating psudoGrowth features at 12 and 17h
```{r}
info.psudoGrowth.timepoints.of.interest <- c(12,72)
psudoGrowth_within.df <- data.frame()
psudoGrowth_beyond.df<-  data.frame()
    


psudoGrowth.perWell.df.subset <- melt(   psudoGrowth.df, id.vars = c("ExpFile",
                                                                      "Well_coordinate",
                                                                      "timestep", 
                                                                      "Time_Hrs" ),
                                variable.name = "Feature")


# This checks whether the 72-hour mark falls *within* or *beyond* the time-lapse.
# If the maximum timepoint is less than or equal to 72h, then the 72h mark lies *beyond* the time-lapse (i.e., it was never acquired).
# If the maximum timepoint exceeds 72h, then the 72h mark is *within* the time-lapse (i.e., it was captured).

  psudoGrowth.perWell.df.subset <-   psudoGrowth.perWell.df.subset  %>%
    dplyr:: mutate(value = as.numeric(value))%>%

    dplyr::mutate(value = if_else(is.na(value),
                                  1,
                                  value)) %>%
    ungroup()%>%
    group_by(ExpFile,
             Well_coordinate)%>%
    mutate(Within.or.beyond = if_else(max(Time_Hrs) <= 72,"Beyond","Within"))%>%
    ungroup()%>%
    mutate(Feature = as.character(Feature))%>%
    dplyr:: mutate(value = as.numeric(value))%>%
    dplyr::mutate(value = if_else(is.na(value), 1,value))  # incase there are no objects so the code does not break.

info.check.within.or.beyond.var <- unique(psudoGrowth.perWell.df.subset$Within.or.beyond)


tp <- info.psudoGrowth.timepoints.of.interest[2]


  if ( info.check.within.or.beyond.var ==  "Within") {
    
      for ( tp in info.psudoGrowth.timepoints.of.interest ) {

psudoGrowth.perWell.df.subset.subset <-   psudoGrowth.perWell.df.subset %>%
  filter(Within.or.beyond == "Within")


    BEFORE <- psudoGrowth.perWell.df.subset.subset%>%
            dplyr::ungroup()%>%
        dplyr::group_by(ExpFile,
                        Well_coordinate,
                        Feature)%>%
        dplyr::filter(timestep >0)%>%
        dplyr::arrange(timestep)%>%
        dplyr::mutate(Time_hrs_before = signif(tp -Time_Hrs, digits = 3))%>%
        dplyr::arrange(timestep)%>%
        dplyr::filter(Time_hrs_before > 0 & lead(Time_hrs_before) < 0 ) %>% # Finding the first instance when a number changes from positive to negative
        dplyr::filter(timestep == min(timestep))



    AFTER <- psudoGrowth.perWell.df.subset.subset %>%
        dplyr::ungroup()%>%
           dplyr::group_by(ExpFile,
                        Well_coordinate,
                        Feature)%>%
        filter(timestep >0)%>%
        arrange(timestep)%>%
        mutate(Time_hrs_before = signif(tp -Time_Hrs, digits = 3))%>%
        filter(Time_hrs_before < 0) %>%
        filter(timestep == min(timestep))

  BEFORE.AFTER <- rbind(  BEFORE  ,
                                 AFTER  )


      #Houskeeping
      rm(  BEFORE ,
           AFTER )

  # Interpolating the values of  features  (e.g totGroth and total n of SC) using the equation of the line.
  BEFORE.AFTER <-  BEFORE.AFTER %>%
    ungroup()%>%
    group_by(ExpFile,
             Feature)%>%
        mutate(value.m =   (nth(value,2)-nth(value,1)) /(nth(Time_Hrs,2) - nth(Time_Hrs,1)),
               value.c = (nth(value,1)-(value.m*nth(Time_Hrs,1))),
               value.rt = (tp*value.m)+value.c )%>%

        ungroup()%>%

        distinct()

    BEFORE.AFTER.results <-   BEFORE.AFTER %>%
      select(-timestep)%>%
      mutate(Feature.val =   value.rt )%>%
      mutate(Time_Hrs =tp )%>%
      select(ExpFile,
             Well_coordinate,
             ExpFile,
             Time_Hrs,
           Feature,
           Feature.val)%>%
      distinct()

    # Saving results in Results table
      psudoGrowth_within.df  <- rbind(psudoGrowth_within.df ,
                               BEFORE.AFTER.results)

     }
    
    
  } else {

#### STARTS HERE 
#### 6.2.4 Long Analysis: Beyond time lapse  ---------------

psudoGrowth.perWell.df.subset.subset <- psudoGrowth.perWell.df.subset

     for ( tp in info.psudoGrowth.timepoints.of.interest ) {

      psudoGrowth.perWell.df.subset.subset


       # If it lies within time lapse
     if (between(tp, min( psudoGrowth.perWell.df.subset.subset$Time_Hrs),
                 max(psudoGrowth.perWell.df.subset.subset$Time_Hrs))
         ){

      psudoGrowth.perWell.df.subset.subset.subset <-   psudoGrowth.perWell.df.subset.subset

       BEFORE <-psudoGrowth.perWell.df.subset.subset.subset%>%
        dplyr::ungroup()%>%
        dplyr::group_by(ExpFile,
                        Well_coordinate,
                        Feature)%>%
        dplyr::filter(timestep >0)%>%
        dplyr::arrange(timestep)%>%
        dplyr::mutate(Time_hrs_before = signif(tp -Time_Hrs, digits = 3))%>%
        dplyr::arrange(timestep)%>%
        dplyr::filter(Time_hrs_before > 0 & lead(Time_hrs_before) < 0 ) %>% # Finding the first instance when a number changes from positive to negative
        dplyr::filter(timestep == min(timestep))



    AFTER <-psudoGrowth.perWell.df.subset.subset.subset %>%
        dplyr::ungroup()%>%
           dplyr::group_by(ExpFile,
                        Well_coordinate,
                        Feature)%>%
        filter(timestep >0)%>%
        arrange(timestep)%>%
        mutate(Time_hrs_before = signif(tp -Time_Hrs, digits = 3))%>%
        filter(Time_hrs_before < 0) %>%
        filter(timestep == min(timestep))

  BEFORE.AFTER <- rbind(  BEFORE,
                                 AFTER  )


      #Houskeeping
      rm(  BEFORE ,
           AFTER )

          # Interpolate live cell fraction found within the equation of the line
  BEFORE.AFTER <-  BEFORE.AFTER %>%
    ungroup()%>%
    group_by(ExpFile,
             Well_coordinate,
             Feature)%>%
        mutate(value.m =   (nth(value,2)-nth(value,1)) /(nth(Time_Hrs,2) - nth(Time_Hrs,1)),
               value.c = (nth(value,1)-(value.m*nth(Time_Hrs,1))),
               value.rt = (tp*value.m)+value.c )%>%

        ungroup()%>%

        distinct()

    BEFORE.AFTER.results <-   BEFORE.AFTER %>%
      select(-timestep)%>%
      mutate(Feature.val =   value.rt )%>%
      mutate(Time_Hrs =tp )%>%
      select(ExpFile,
             Well_coordinate,
             Time_Hrs,
           Feature,
           Feature.val)%>%
      distinct()

    # Saving results in Results table
      psudoGrowth_beyond.df <- rbind(    psudoGrowth_beyond.df ,
                               BEFORE.AFTER.results)
     }else {



     BEFORE.AFTER <-psudoGrowth.perWell.df.subset.subset %>%
        ungroup()%>%
        dplyr::group_by(ExpFile,
                        Well_coordinate,
                        Feature)%>%
        dplyr::arrange(timestep)%>%
        top_n(2, wt = timestep)

      # Interpolate live cell fraction found within the equation of the line
          BEFORE.AFTER <- BEFORE.AFTER  %>%
        ungroup()%>%
       dplyr::group_by(ExpFile,
                        Well_coordinate,
                        Feature)%>%
        arrange(timestep)%>%
       group_by(Feature)%>%
        mutate(value.m =   (nth(value,2)-nth(value,1)) /(nth(Time_Hrs,2) - nth(Time_Hrs,1)),
               value.c = (nth(value,1)-(value.m*nth(Time_Hrs,1))),
               value.rt = (tp*value.m)+value.c )%>%

        distinct()

    BEFORE.AFTER.results <-   BEFORE.AFTER %>%
      select(-timestep)%>%
      mutate(Feature.val =   value.rt )%>%
      mutate(Time_Hrs =tp )%>%
      select(ExpFile,
             Well_coordinate,
             Time_Hrs,
           Feature,
           Feature.val)%>%
      distinct()

    # Saving results in Results table
    psudoGrowth_beyond.df <- rbind(  psudoGrowth_beyond.df  ,
                               BEFORE.AFTER.results)




  }

  }
}

psudoGrowth_interpol.vals.df <- rbind(psudoGrowth_within.df,
                    psudoGrowth_beyond.df)

#Houskeeping
rm(BEFORE.AFTER,
   BEFORE.AFTER.results,
   psudoGrowth.perWell.df.subset,
   psudoGrowth.perWell.df.subset.subset,
   psudoGrowth.perWell.df.subset.subset.subset,
   psudoGrowth_beyond.df,
   psudoGrowth_within.df)



psudoGrowth.concatenated.df <- melt(  psudoGrowth.df , id.vars = c("ExpFile",
                                                                      "Well_coordinate",
                                                                      "timestep", 
                                                                      "Time_Hrs" ),
                                variable.name = "Feature")

psudoGrowth.concatenated.df<- psudoGrowth.concatenated.df %>%
  ungroup()%>%
  distinct()%>%
  mutate(Feature = as.character(Feature))%>%
  mutate(Feature.val = as.numeric(value))%>%
  select(-value)


psudoGrowth.concatenated.df<- psudoGrowth.concatenated.df %>%
  select(-timestep)


psudoGrowth.concatenated.df <- rbind(psudoGrowth.concatenated.df,
                           psudoGrowth_interpol.vals.df)


# Accounting for latent antibiotic action by considering psudoGrowth from 12 hours onwards.
psudoGrowth.concatenated.df <- psudoGrowth.concatenated.df %>%
  ungroup()%>%
  filter(Time_Hrs >= 12)%>%
    filter(Time_Hrs <= 72)%>%
    dplyr::mutate(Feature.val = if_else(is.na(Feature.val), 1,Feature.val))




psudoGrowthFeature.1 <- psudoGrowth.concatenated.df  %>%
  ungroup()%>%
  filter( Feature == "psudoGrowth_nSC")%>%
  group_by(Well_coordinate,
           Feature)%>%
  arrange(Time_Hrs)%>%
  mutate(Ratio = Feature.val/ first(Feature.val),
         MaxRatio= max(Ratio),
         MinRatio = min(Ratio))%>%
  mutate(psudoGrowth_nSC_corr.none_minRatio = MinRatio)%>%
  ungroup()%>%
  select(ExpFile,
         Well_coordinate,
      psudoGrowth_nSC_corr.none_minRatio)%>%
  distinct()

# --- 
psudoGrowthFeature.2 <- psudoGrowth.concatenated.df

psudoGrowthFeature.2  <- spread(psudoGrowthFeature.2  ,
                           key = Feature,
                     value =  Feature.val)

psudoGrowthFeature.2.PLOT  <- psudoGrowthFeature.2  %>%
  group_by(ExpFile,
           Well_coordinate)%>%
  arrange(Time_Hrs)%>%
  mutate(psudoGrowth_totObjArea_corr.nSCVS =  (psudoGrowth_totObjArea /psudoGrowth_nSC.VS) / (dplyr::first(psudoGrowth_totObjArea)/dplyr::first(psudoGrowth_nSC.VS) ))%>%
  ungroup()%>%
  select(ExpFile,
         Well_coordinate,
         Time_Hrs,
        psudoGrowth_totObjArea_corr.nSCVS)


psudoGrowthFeature.2  <- psudoGrowthFeature.2  %>%
  group_by(ExpFile,
           Well_coordinate)%>%
  arrange(Time_Hrs)%>%
  mutate(psudoGrowth_totObjArea_corr.nSCVS =  (psudoGrowth_totObjArea /psudoGrowth_nSC.VS) / (dplyr::first(psudoGrowth_totObjArea)/dplyr::first(psudoGrowth_nSC.VS) ))%>%
  ungroup()%>%
  select(ExpFile,
         Well_coordinate,
         Time_Hrs,
        psudoGrowth_totObjArea_corr.nSCVS)



  
psudoGrowthFeature.2 <- melt( psudoGrowthFeature.2  , id.vars =  c ("ExpFile",
                                              "Well_coordinate",
                                              "Time_Hrs"),
                      variable.name = "Feature",
                   value.name =  "Feature.val")

psudoGrowthFeature.2 <- psudoGrowthFeature.2 %>%
        ungroup()%>%
  group_by(Well_coordinate,
           Feature)%>%
  arrange(Time_Hrs)%>%
  mutate(
         MaxRatio= max(Feature.val),
         MinRatio = min(Feature.val))%>%
  ungroup()%>%
  mutate(psudoGrowth_totObjArea_corr.nSCVS_maxRatio = MaxRatio)%>%
  select(ExpFile,
         Well_coordinate,
        psudoGrowth_totObjArea_corr.nSCVS_maxRatio)%>%
  distinct()

psudoGrowth.feature.df <- left_join(psudoGrowthFeature.1,
                           psudoGrowthFeature.2)

psudoGrowth.feature.df <- psudoGrowth.feature.df %>%
  mutate(psudoGrowth_evaluation = if_else(log10(psudoGrowth_totObjArea_corr.nSCVS_maxRatio) > 0.5 , "psudoGrowth", "no-psudoGrowth"))

#Housekeeping
rm(psudoGrowth.df,
   psudoGrowth_interpol.vals.df,
   psudoGrowth.concatenated.df,
   psudoGrowthFeature.1,
   psudoGrowthFeature.2)

```


# 6. Matlab Single cell tracking
## 6.1 Loading matlab single cell tracking
```{r}

  trk.filename <- list.files(path = info.matlab.trk.dir,
                             pattern = "*.csv",
                             full.names = FALSE)


matlab.trk.df <- read.csv(paste(info.matlab.trk.dir,
                            "/",
                            trk.filename,
                            sep=""))

matlab.trk.df <- matlab.trk.df %>%
    dplyr::mutate(TrackID = as.numeric(TRK_ID),
           labelimage_oid = as.numeric(ilastik_ID),
           timestep = as.numeric(Time) -1)%>%
    select(-TRK_ID,
           -ilastik_ID,
           -Time)


matlab.trk.df <- separate(matlab.trk.df, col = well_coord,
                             into = c("Exp",
                                      "Well_coordinate",
                                      "Field"),
                             sep = "_")

matlab.trk.df <- matlab.trk.df %>%
  dplyr::mutate(Field = as.numeric(gsub("p0", "",Field)))%>%
  select_if(~!all(is.na(.))) 

  matlab.trk.df <- matlab.trk.df %>%
    mutate(ExpFile = info.expID)
  
```


## 6.1 Merge single cell tracking with viability assessment
```{r}
matlab.trk.df <- left_join(matlab.trk.df,
                             ASCT.poc.df)

#  ~~~~ merge with block below ~~~~~
```

### 6.1.1 Excluding missing trackIDs 
```{r}
matlab.trk.df <- matlab.trk.df %>%
dplyr::ungroup() %>%
     group_by(Well_coordinate, 
              Field, 
              TrackID) %>%
    dplyr::mutate(NAs_in_Ila_Mean_Intensity = sum(is.na(Mean.IntensityBaSic)))%>%
  dplyr::mutate(Consecutive_NAs = ifelse(is.na(Mean.IntensityBaSic) & 
                                         (is.na(lag(Mean.IntensityBaSic)) | 
                                            is.na(lead(Mean.IntensityBaSic))), 
                                       1,0))%>%
    dplyr::mutate(Sum.of.Consecutive_NAs = sum(Consecutive_NAs))%>%
    dplyr::ungroup()%>%
    filter(Sum.of.Consecutive_NAs <= 2)%>%
    filter(NAs_in_Ila_Mean_Intensity <= 6)%>%
  dplyr::ungroup()%>%
 group_by(Well_coordinate,
             Field,
             TrackID)%>% # MF abbreviation for Missing Frames ; if MF then check the previous Frame and apply the POC (pi/viability classification) of the previous frame. Repeat this 6 times so we do not have missing values
    dplyr::mutate(Mean.IntensityBaSic.MF1 = if_else(is.na(Mean.IntensityBaSic), lag(Mean.IntensityBaSic), Mean.IntensityBaSic),
           Mean.IntensityBaSic.MF2 = if_else(is.na(Mean.IntensityBaSic.MF1 ), lag(Mean.IntensityBaSic.MF1 ), Mean.IntensityBaSic.MF1),
           Mean.IntensityBaSic.MF3 = if_else(is.na(Mean.IntensityBaSic.MF2 ), lag(Mean.IntensityBaSic.MF2 ), Mean.IntensityBaSic.MF2),
           Mean.IntensityBaSic.MF4 = if_else(is.na(Mean.IntensityBaSic.MF3 ), lag(Mean.IntensityBaSic.MF3 ), Mean.IntensityBaSic.MF3),
           Mean.IntensityBaSic.MF5 = if_else(is.na(Mean.IntensityBaSic.MF4 ), lag(Mean.IntensityBaSic.MF4 ), Mean.IntensityBaSic.MF4),
           Mean.IntensityBaSic.MF6 = if_else(is.na(Mean.IntensityBaSic.MF5 ), lag(Mean.IntensityBaSic.MF5 ), Mean.IntensityBaSic.MF5))%>%
 dplyr::mutate(POC.Predicted.Class.MF1 = if_else(is.na(POC.Predicted.Class), lag(POC.Predicted.Class), POC.Predicted.Class),
           POC.Predicted.Class.MF2 = if_else(is.na(POC.Predicted.Class.MF1 ), lag(POC.Predicted.Class.MF1 ), POC.Predicted.Class.MF1),
           POC.Predicted.Class.MF3 = if_else(is.na(POC.Predicted.Class.MF2 ), lag(POC.Predicted.Class.MF2 ), POC.Predicted.Class.MF2),
           POC.Predicted.Class.MF4 = if_else(is.na(POC.Predicted.Class.MF3 ), lag(POC.Predicted.Class.MF3 ), POC.Predicted.Class.MF3),
           POC.Predicted.Class.MF5 = if_else(is.na(POC.Predicted.Class.MF4 ), lag(POC.Predicted.Class.MF4 ), POC.Predicted.Class.MF4),
           POC.Predicted.Class.MF6 = if_else(is.na(POC.Predicted.Class.MF5 ), lag(POC.Predicted.Class.MF5 ), POC.Predicted.Class.MF5))%>%
   select(
           Well_coordinate,
           Field,
           TrackID,
           timestep,
           ExpFile,
           Mean.IntensityBaSic,
           Mean.IntensityBaSic.MF6,
           POC.Predicted.Class,
           POC.Predicted.Class.MF6)%>%
 dplyr::ungroup()%>%
    dplyr::mutate(Mean.IntensityBaSic = Mean.IntensityBaSic.MF6,
           POC.Predicted.Class = POC.Predicted.Class.MF6)%>%
    select(-Mean.IntensityBaSic.MF6,
           -POC.Predicted.Class.MF6)


```


```{r}
#----- Ilastik 2: Twice positive always postive: if trackID in terms of viability assessment is classified ad piPosistive for two consecutive timepoints then the trackID from the first instance of piPOS is classified piPOS for the rest of the info.timelapse


matlab.trk.df <- matlab.trk.df %>%
    dplyr::ungroup() %>%
    group_by(ExpFile,
             Well_coordinate,
             Field,
             TrackID) %>%
    dplyr::mutate(Predicted_Class_Pi_Pos = if_else(POC.Predicted.Class == "piPOS", 1, 0)) %>%
    dplyr::mutate(Consecutive_Pi_Pos = if_else(lead(Predicted_Class_Pi_Pos) == 1 & Predicted_Class_Pi_Pos == 1, 1, 0)) %>%
    dplyr::mutate(Consecutive_Pi_Pos_Count = cumsum(Consecutive_Pi_Pos)) %>%
    dplyr::mutate(Predicted_Class_Status = if_else(Consecutive_Pi_Pos_Count >= 1, "piPOS", "piNEG")) %>%
    dplyr::ungroup() %>%
    group_by(Well_coordinate,
             Field,
             TrackID,
             timestep) %>%
    dplyr::mutate(POC.Predicted.Class = if_else(timestep == max(timestep) && is.na(Predicted_Class_Status), "piPOS", as.character(Predicted_Class_Status)))%>%
    dplyr::ungroup()%>%
  dplyr::mutate(Exp_Well_Field_TrackID = paste(info.expID,
                                       Well_coordinate,
                                       Field,
                                       TrackID))%>%
    select(
      -Consecutive_Pi_Pos,
      -Consecutive_Pi_Pos_Count,
      -Predicted_Class_Status,
      -Predicted_Class_Pi_Pos)


```





# 7. Assessing fractions of live cells per timepoint of tracking data
```{r}

# Tracking data 

  # ---- Calculate ilastik live cell fraction 
  
  #--- Pi POS Neg numbers
  Tracking_LCF <-  matlab.trk.df%>%
    dplyr::select(
   Exp_Well_Field_TrackID,
      Well_coordinate,
      Field,
      TrackID,
      timestep,
      POC.Predicted.Class)%>%
    dplyr::ungroup()%>%
    dplyr::group_by(
      Well_coordinate,
      timestep,
       POC.Predicted.Class) %>%
    summarise(n = n()) %>%
    dplyr::mutate(Trk_LCF = n/sum(n)) %>%
    dplyr::mutate(Trk_Number = n)%>%
    dplyr::select(-n)%>%
    dplyr::ungroup()%>%
  group_by(Well_coordinate, timestep) %>%
  summarise(
    Trk_uncorr.frac.piNEG_frac.piPOS = paste(
      if_else(POC.Predicted.Class == "piNEG", 
              paste(Trk_LCF, sep = ""), 
              paste( Trk_LCF, sep = "")), 
      collapse = "_"
    ),
   Trk_n.piNEG_n.piPOS = paste(
      if_else(POC.Predicted.Class == "piNEG", 
              paste(Trk_Number,  sep = ""), 
              paste(Trk_Number,  sep = "")), 
      collapse = "_"
    ),
   Trk_Tot.N = sum(Trk_Number)
  ) %>%
  ungroup()

# Adding time metadata


Tracking_LCF <- left_join(Tracking_LCF,
                          ASCT.metadata.df)

Tracking_LCF <-Tracking_LCF %>%
  mutate(ExpID = info.expID) %>%
  mutate(LCF_fraction =  as.numeric(sub("_.*", "", Trk_uncorr.frac.piNEG_frac.piPOS)))%>%
  select(ExpID,
         Well_coordinate,
         timestep,
         Time_Hrs,
         LCF_fraction,
         everything())

#Houskeeping
rm(matlab.trk.df)
```

## 7.1 finding max live cell fraction at 0h with fitting
```{r}
# 4. Fitting tracking (from Matlab script written by Ahmad) ----

# Using chatgpt4; I translated the matlab code (fit_Logistics_func.m / FITfunc.m) written by Ahmad to R.
# I checked the result agains a single well data and fitting results and it was the same.


## 4.1 Logistic fitting function ----
fit_Logistics_func <- function(x, y) {
  m <- length(x)
  w <- (m:1)^2 / y^2
  
  x0max <- 40
  L1max <- 4
  E1_max <- 100
  
  iter_x0 <- 400
  iter_L1 <- 400
  iter_c11 <- 1000
  iter_c12 <- 900
  iter_c1 <- iter_c11 + iter_c12
  
  x0_interval <- x0max / iter_x0
  L_interval <- L1max / iter_L1
  c_interval11 <- 0.01
  c_interval12 <- 0.1
  
  cost_fun <- matrix(1000, nrow = iter_x0, ncol = iter_c1)
  
  for (x0ind in 1:iter_x0) {
    x0 <- x0ind * x0_interval
    for (c1ind in 1:iter_c1) {
      c1 <- min(c1ind, iter_c11) * c_interval11 + max(0, c1ind - iter_c11) * c_interval12
      
      c1_term <- c1 * x - c1 * x0
      c1_L1 <- c1 * x[1] - c1 * x0
      L1 <- y[1] * (1 + exp(c1_L1))
      fx <- L1 / (1 + exp(c1_term))
      
      cost_fun[x0ind, c1ind] <- sum(w * ((fx - y)^2))
    }
  }
  
  min_cost <- min(cost_fun)
  min_index <- which(cost_fun == min_cost, arr.ind = TRUE)
  
  x0min <- min_index[1] * x0_interval
  cmin <- min(min_index[2], iter_c11) * c_interval11 + max(0, min_index[2] - iter_c11) * c_interval12
  c1_L1 <- cmin * x[1] - cmin * x0min
  Lmin <- y[1] * (1 + exp(c1_L1))
  
  list(x0min = x0min, Lmin = Lmin, cmin = cmin, costM = min_cost)
}

# Initialize list for initial values
Fitting.LCF.0h <- numeric()

# Define the time and y values for the logistic fitting
x <- Tracking_LCF$Time_Hrs[1:5]
y <-Tracking_LCF$LCF_fraction[1:5]

# Perform the logistic fitting
fit <- fit_Logistics_func(x, y)

# Define the logistic function based on the fitting results
logistic_one <- function(x) fit$Lmin / (1 + exp(fit$cmin * x - fit$cmin * fit$x0min))
Fitting.LCF.0h <- c(Fitting.LCF.0h, logistic_one(0))



#Housekeeping
rm(x,
   y,
   fit)

Tracking_LCF <- Tracking_LCF %>%
    dplyr::mutate(timestep = timestep + 1)


# Correcting time kill curve based on fitting value ----

Tracking_LCF.corr <- Tracking_LCF %>%
  dplyr::ungroup()%>%
  dplyr::group_by(Well_coordinate)%>%
  dplyr::arrange(timestep)%>%
  dplyr::mutate(LCF_fraction.corr= (1/Fitting.LCF.0h)*LCF_fraction)%>%
  dplyr::ungroup()%>%
  dplyr::select(
        ExpID,
        Well_coordinate,
         timestep,
         Time_Hrs,
         LCF_fraction.corr)


# Add timestep 0 and Time_hrs 0 and Live cell fraction 1 for all isolates
 TKC.corr.0th.tp <-  Tracking_LCF.corr %>%
  dplyr::ungroup()%>%
  dplyr::slice(1)%>%
  dplyr::distinct()%>%
  dplyr::mutate(timestep = 0,
         Time_Hrs = 0,
         LCF_fraction.corr = 1)
 

Tracking_LCF.corr <- rbind(Tracking_LCF.corr,
                  TKC.corr.0th.tp)


Tracking_LCF.corr <- left_join(Tracking_LCF.corr,
                               Tracking_LCF,
                               by = join_by(ExpID,
                                            Well_coordinate,
                                            timestep,
                                            Time_Hrs))

Fitting.LCF.0h <- as.numeric(Fitting.LCF.0h)

#Houskeeping
rm(Tracking_LCF,
   TKC.corr.0th.tp)


head(Tracking_LCF.corr)
```


```{r}
Tracking_LCF.corr <- Tracking_LCF.corr %>%
    dplyr::ungroup()%>%
  dplyr::mutate(LCF_fraction = if_else(timestep == 0 & is.na(LCF_fraction), 
                                 Fitting.LCF.0h, 
                                 LCF_fraction),
         Trk_uncorr.frac.piNEG_frac.piPOS = if_else(timestep == 0 & is.na(Trk_uncorr.frac.piNEG_frac.piPOS), 
                                paste(Fitting.LCF.0h,
                                      "_",
                                      paste(1-Fitting.LCF.0h),
                                      sep=""), 
                                 Trk_uncorr.frac.piNEG_frac.piPOS),
         Trk_Tot.N = if_else(timestep == 0 & is.na(Trk_Tot.N), 
                                unique(na.omit(Tracking_LCF.corr$Trk_Tot.N)) , 
                                 Trk_Tot.N))
  
  
Tracking_LCF.corr <- Tracking_LCF.corr %>%
  mutate(Trk_n.piNEG_n.piPOS = if_else(
    timestep == 0 & is.na(Trk_n.piNEG_n.piPOS),
    paste(
      ceiling(Fitting.LCF.0h * Trk_Tot.N), "_",  # Calculate before pasting
      floor((1 - Fitting.LCF.0h) * Trk_Tot.N)
    ,sep=""),
    Trk_n.piNEG_n.piPOS
  ))

```



## 7.2 Interpolating live cell fractions at distinct timepoints 

```{r}

# How long was this info.timelapse experiment? Was a 24, 48 ,72 or 96h info.timelapse
info.timelapse <- c(72)
# Based on the duration of the time-lapse, what real-time live cell fractions values are you interested in? 
info.interpol.values.interest <- c(3,6,9,12,24,36,48,60,72 )

# Ranges of AUC of interest e.g. from 0-3h or from 12-24h.
info.auc.of.interest <- c("0-3","0-6","0-9","0-24", "0-36", "0-48", "0-60", "0-72")



#--- Killing feature  real time live cell fraction --

# Soft-Coded: Real-Time Live Cell Fraction Estimation via Interpolation
#
# Goal: Estimate the live cell fraction at a desired time point using linear interpolation.
# Steps:
# 1. Identify the two closest time points in the dataset (one before and one after the desired time).
# 2. Extract the corresponding live cell fraction values.
# 3. Use the equation of a line (y = m * x + c) to interpolate the live cell fraction at the desired time.
#    - Slope (m) is calculated as: (y2 - y1) / (t2 - t1)
#    - Interpolated value (y) is found using: y = m * desired_time + c
#
# Edge Cases:
# - If the desired time is outside the range of available time points (e.g., metadata only goes up to 48 hours),
#   select the nearest available time instead of interpolating beyond known data.
#----

interpol.df <- Tracking_LCF.corr %>%
  select(ExpID,
                  Well_coordinate,
         timestep,
         Time_Hrs,

         LCF_fraction.corr)


interpol.df.Long <- melt(interpol.df,
                   id.vars = c("ExpID",
                               "Well_coordinate",
                               "timestep",
                               "Time_Hrs"
                   ),
                   variable.name =  "Killing.Features",
                   value.name = "LC.fraction" )



# Creating empty results dataframe
Killing.Features.df.1 <- data.frame()

# Loop through killing defition
info.list.of.killing.def <- unique(as.character(interpol.df.Long$Killing.Features))
#i <- info.list.of.killing.def[1]

# list of real time values we are interested in
info.list.of.real.time.values <- info.interpol.values.interest 

#j <- info.list.of.real.time.values[1]



for ( i in info.list.of.killing.def ) {
  
  print(paste("Assessing real-time live cell fraction of killing Def:", i))
  
  # selecting specific killing feature
  interpol.df.Long.sub <- interpol.df.Long %>%
    dplyr::ungroup()%>%
    filter(Killing.Features == i)
  
  for (j in info.list.of.real.time.values) {
    print(paste("For killing Def:", i, "calculating the live cell fraction at" , j ,"hrs."))
    
    
    
    if (between(j, min(interpol.df.Long.sub$Time_Hrs), max(interpol.df.Long.sub$Time_Hrs))){
      
      
      # WITHIN 
      print( paste("Time of interest",j, "lies within info.timelapse" ,sep =" "))
      interpol.df.Long.sub.interpol.BEFORE <- interpol.df.Long.sub %>%
        dplyr::ungroup()%>%
        dplyr::group_by(Well_coordinate)%>%
        dplyr::filter(timestep >0)%>%
        dplyr::arrange(timestep)%>%
        dplyr::mutate(Time_hrs_before = signif(j-Time_Hrs, digits = 3))%>%
        dplyr::arrange(timestep)%>%
        dplyr::filter(Time_hrs_before > 0 & lead(Time_hrs_before) < 0 ) %>% # Finding the first instance when a number changes from positive to negative
        dplyr::filter(timestep == min(timestep))
      
      
      
      interpol.df.Long.sub.interpol.AFTER<- interpol.df.Long.sub %>%
        dplyr::ungroup()%>%
        dplyr::group_by(Well_coordinate)%>%
        filter(timestep >0)%>%
        arrange(timestep)%>%
        mutate(Time_hrs_before = signif(j-Time_Hrs, digits = 3))%>%
        filter(Time_hrs_before < 0) %>%
        filter(timestep == min(timestep))
      
      interpol.df.Long.sub.rt <- rbind(interpol.df.Long.sub.interpol.BEFORE ,
                                 interpol.df.Long.sub.interpol.AFTER  )
      
      
      #Houskeeping
      rm(interpol.df.Long.sub.interpol.BEFORE ,
         interpol.df.Long.sub.interpol.AFTER)
      
      
      # Interpolate live cell fraction found within the equation of the line
      interpol.df.Long.sub.rt <- interpol.df.Long.sub.rt %>%
        mutate(LC.fraction.m =   (nth(LC.fraction,2)-nth(LC.fraction,1)) /(nth(Time_Hrs,2) - nth(Time_Hrs,1)),
               LC.fraction.c = (nth(LC.fraction,1)-(LC.fraction.m*nth(Time_Hrs,1))),
               LC.fraction.interpol = (j*LC.fraction.m)+LC.fraction.c )%>% 
        ungroup()%>%
        mutate(KF.1.var = paste(Killing.Features,
                                ".",
                                j,
                                "h",
                                sep=""))%>%
        select(-LC.fraction.m ,
               -LC.fraction.c)%>%
        select(ExpID,
               Well_coordinate,
               LC.fraction.interpol,
               KF.1.var)%>%
        distinct()

      
      
    } else { 
      
      
      print(paste("Time of interest",j, "lies BEYOND info.timelapse"))
      
      interpol.df.Long.sub.rt <- interpol.df.Long.sub %>%
        ungroup()%>%
        dplyr::group_by(Well_coordinate)%>%
        dplyr::arrange(timestep)%>%
        top_n(2, wt = timestep)
      
      # Interpolate live cell fraction found within the equation of the line
      interpol.df.Long.sub.rt  <- interpol.df.Long.sub.rt %>%
        ungroup()%>%
        group_by(Well_coordinate)%>%
        arrange(timestep)%>%
        mutate(LC.fraction.m =   (nth(LC.fraction,2)-nth(LC.fraction,1)) /(nth(Time_Hrs,2) - nth(Time_Hrs,1)),
               LC.fraction.c = (nth(LC.fraction,1)-(LC.fraction.m*nth(Time_Hrs,1))),
               LC.fraction.interpol = (j*LC.fraction.m)+LC.fraction.c )%>% 
        ungroup()%>%
        mutate(KF.1.var = paste(Killing.Features,
                                ".",
                                j,
                                "h",
                                sep=""))%>%
        select(-LC.fraction.m ,
               -LC.fraction.c)%>%
        select(ExpID,
               Well_coordinate,
               LC.fraction.interpol,
               KF.1.var)%>%
        distinct()
      
      
      
    }
    
    
    Killing.Features.df.1 <- rbind(Killing.Features.df.1,interpol.df.Long.sub.rt )
    
  }
  
}

#Housekeeping
rm(i,
   j,
   info.list.of.killing.def,
   trk.filename,
   interpol.df.Long.sub,
   interpol.df.Long.sub.rt,
   interpol.df)
```

### 7.2.1 Concatenating interploated LCF values to main timelapse

```{r}

interpol.concatenated.df <- interpol.df.Long %>%
  select(-timestep)


interpol.kf1 <- Killing.Features.df.1 %>%
  ungroup()%>%
  mutate(  
           Time_Hrs = gsub("LCF_fraction.corr.",
                           "",
                           KF.1.var),
           Time_Hrs = gsub("h","",Time_Hrs),
           Time_Hrs = as.numeric(Time_Hrs))%>%
  group_by(KF.1.var)%>%
  mutate(Killing.Features = gsub( paste(".",
                                  Time_Hrs,
                                  "h",
                                  sep=""),"",KF.1.var))%>%
  mutate(Killing.Features = as.factor(Killing.Features))%>%
mutate(LC.fraction = LC.fraction.interpol)%>%
ungroup()%>%
  select(ExpID,
         Well_coordinate,
         LC.fraction,
         Killing.Features,
         Time_Hrs)
  

interpol.concatenated.df <- rbind(interpol.concatenated.df,
                                interpol.kf1)


#Houskeeping
rm(interpol.kf1,
   interpol.df.Long)
```


#8.  Caluclating Area under the time kill curve using the trapezium rule
```{r}
#--------------   AUC linear-scale  across real time intervals --------------

# Now we will calculate the AUC between 2 consecutive timepoints across the time lapse. Essentially splitting the time-kill curve into many little trapeziums and applying the trapezium rule (https://www.vivaxsolutions.com/maths/altrapzrule.aspx#google_vignette) to calculate the area under the curve.

auc.interpol.df <- interpol.concatenated.df
KF.AUC.multiple.trapz <- data.frame()

# Loop through definitions
info.list.of.killing.def <- unique(as.character(auc.interpol.df$Killing.Features))
info.list.of.killing.def <- sort(info.list.of.killing.def)
i <- info.list.of.killing.def[1]


# Loop through image frames
info.list.of.hrs.timepoints <- unique(auc.interpol.df$Time_Hrs)
info.list.of.hrs.timepoints <- sort(info.list.of.hrs.timepoints)
info.list.of.hrs.timepoints

max(info.list.of.hrs.timepoints)

for ( i in info.list.of.killing.def ) {
  
  print(paste("AUC across frame of killing Def:", i)) 
  
  # selecting specific killing feature 
  auc.interpol.df.sub <- auc.interpol.df %>%
    dplyr::ungroup()%>%
    filter(Killing.Features == i)
  

  for (j in  info.list.of.hrs.timepoints ) {
    #j <- info.list.of.hrs.timepoints[1]
    
    auc.interpol.df.sub.sub <-auc.interpol.df.sub %>%
      ungroup()%>%
      filter(Time_Hrs >= j)%>%
      top_n(-2,Time_Hrs)%>%
      group_by(Well_coordinate) %>%
      arrange(Time_Hrs)%>%
      mutate(# difference in lead and current time_hrs gives us h
        AUC.trapz = (sum(LC.fraction) /2)*(lead(Time_Hrs)-Time_Hrs)) # We will have NAs with this calculation because It is applied across each tim_hrs 
    
    #Important to define the next time interval which indecates the range of AUC
    next.time <-  round( max(auc.interpol.df.sub.sub$Time_Hrs), digits = 3)
    current.time <- round(j, digits =3)
    
    auc.interpol.df.sub.sub <-   auc.interpol.df.sub.sub %>%
      mutate(AUC.realtime.int = paste("AUC.TimeInterval_",
                                      current.time, 
                                      "-",
                                      next.time,
                                      sep =""))%>%
      select(
        -Time_Hrs,
        -LC.fraction)%>%
      distinct()%>%
      drop_na() 
    
    
    KF.AUC.multiple.trapz <- rbind(KF.AUC.multiple.trapz,   auc.interpol.df.sub.sub )
    
    #Houskeeping
    rm(next.time,
       current.time)
    
  }
  
}

#Houskeeping
rm(auc.interpol.df.sub,
   auc.interpol.df.sub.sub)

KF.AUC.multiple.trapz <- KF.AUC.multiple.trapz  %>%
  ungroup()%>%
  mutate(Time.Int = as.numeric(sub(".*-",
                                   "",
                                   AUC.realtime.int)))

#---- Calculating the AUC across timestep intervals
# Derive image frame inter
Killing.Features.df.2auc <- data.frame()

info.set.of.intervals <- KF.AUC.multiple.trapz$Time.Int 



info.list.of.killing.def <- unique(as.character(KF.AUC.multiple.trapz$Killing.Features))
info.list.of.killing.def 
k <- info.list.of.killing.def[1]
# Define the relevant image frames we aim to consider
l <- info.auc.of.interest[8]
# Now we will sum the many trapeziums across the relevant time intervals

for ( k in info.list.of.killing.def ) {
  
  KF.AUC.multiple.trapz.sub <- KF.AUC.multiple.trapz %>%
    filter(Killing.Features == k)
  
  print(paste("AUC killing Def:", k))
  
  for ( l in info.auc.of.interest) {
    
    print(paste("AUC time interval:", l))
    
    # intervals are given by e.g. 0-3. We therfore find the numeber before and after the delimiter - to define the range of AUCs of interest
    from <- as.numeric(gsub( "-.*", "", l))
    #  from
    to <- as.numeric(sub( ".*-", "", l))
    #  to
    
    KF.AUC.multiple.trapz.sub.sub <-  KF.AUC.multiple.trapz.sub %>%
      filter(  Time.Int >= from)%>%
      filter(  Time.Int <= to)%>%
      mutate(KF.2.auc.sum = sum(AUC.trapz),
             KF.2.Intervals = paste(from,
                                    "_",
                                    to ,
                                    sep=""))
    
    Killing.Features.df.2auc <- rbind( Killing.Features.df.2auc,KF.AUC.multiple.trapz.sub.sub )
    
    rm( KF.AUC.multiple.trapz.sub.sub)
    
  }
  
}

Killing.Features.df.2auc <- Killing.Features.df.2auc  %>%
  ungroup()%>%
  select(-Time.Int,
         -AUC.trapz,
         -AUC.realtime.int)%>%
  distinct()

Killing.Features.df.2auc <- Killing.Features.df.2auc  %>%
  mutate(KF.2.var = paste(
                        "AUCrt",
                        gsub("_",".",KF.2.Intervals),
                        
                        sep=""),
         KF.2.var = paste(KF.2.var,
                          "h",sep=""))%>%
  select(-KF.2.Intervals,
         -Killing.Features)


# AUCrt0.72h
#Houskeeping
rm(auc.interpol.df,
   KF.AUC.multiple.trapz,
   KF.AUC.multiple.trapz.sub,
   j,k,l,to,from,i)

```


# 9. Plots
## 9.1 Creating results directory if it does not exist
```{r}
# Create a results directory if it doesnt exist.

if (!any(grepl("_Results", list.dirs(".", FALSE, FALSE)))) {
  dir.create(paste(info.expID,
                   "_",
                   info.well,
                   "_Results",
                   sep=""))
  message("Created the results directory")
} else {
  message("The results directory already exists already exists.")
}


# Flag psudoGrowth and tracked number


# PLOTTING TIME KILL CURVES
plot.filename <- paste(info.wd,
                       paste("/",
                         info.expID,
                   info.well,
                   "_Results/",
                   sep=""),
                       info.expID,
                   "_",
                       info.well,
                       "_Timekillcurve.pdf", sep = "")



```

## 9.2 Time kill curve plot

```{r}
# Step 1: Create a separate data frame with just the vertical lines info
vline.df <- interpol.concatenated.df %>%
  filter(Time_Hrs %in% info.interpol.values.interest) %>%
  distinct(ExpID, Well_coordinate, Time_Hrs, LC.fraction)

auc.labels <- Killing.Features.df.2auc %>%
  filter(KF.2.var == "AUCrt0.72h") %>%
  mutate(label = paste(gsub("AUCrt0.72h","AUC: ",KF.2.var), round(KF.2.auc.sum, 3),
                       sep=""))

auc.labels<- auc.labels$label


p1.timekillcurve.plot <- interpol.concatenated.df %>%
  distinct() %>%
  mutate(point_type = case_when(
    Time_Hrs == 0 ~ "Fitted",
    Time_Hrs %in% info.interpol.values.interest ~ "Interpolated values",
    TRUE ~ "Measured"
  )) %>%
  mutate(point_type = factor(point_type,
                             levels = c("Fitted", "Interpolated values", "Measured"))) %>%
  ggplot(aes(x = Time_Hrs,
             y = LC.fraction,
             group = Well_coordinate,
             label = Well_coordinate)) +

  geom_line(alpha = 0.5, size = 1) +

  geom_point(aes(color = point_type), size = 2) +

  scale_color_manual(
    name = NULL,
    values = c("Measured" = "black",
               "Interpolated values" = "red",
               "Fitted" = "darkblue")
  ) +

  geom_area(data = interpol.concatenated.df %>% filter(Time_Hrs <= 72),
            aes(x = Time_Hrs, y = LC.fraction, group = Well_coordinate),
            fill = "steelblue", alpha = 0.4,
            inherit.aes = FALSE) +

  geom_segment(data = vline.df,
               aes(x = Time_Hrs, xend = Time_Hrs,
                   y = 0, yend = LC.fraction,
                   group = Well_coordinate),
               inherit.aes = FALSE,
               linetype = "dashed",
               alpha = 0.2,
               color = "red",
               size = 0.3) +

  annotate("text", x = 36, y = 1.0,
           label = "Time kill curve",
           size = 6, hjust = 0.5) +
    annotate("text", x = 36, y = 0.9,
           label = auc.labels,
           size = 4, hjust = 0.5) +

  scale_y_continuous(
    breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1),
    limits = c(0, 1),
    name = "Fraction of cells alive"
  ) +

  scale_x_continuous(
    breaks = info.plot.xaxis.time.scale,
    name = "Time (hrs)"
  ) +

  theme_pubr() +
  theme(
    legend.position = c(0.4, 0.70),             # moved legend leftward
    legend.justification = c(0, 1),
    legend.direction = "vertical",
    legend.title = element_blank(),
    legend.key.size = unit(0.3, "cm"),
    legend.key.width = unit(0.5, "cm"),
    legend.text = element_text(size = 8),

    aspect.ratio = 1,
    strip.background = element_blank(),
    strip.text = element_blank(),
    axis.text = element_text(size = 9),
    plot.margin = margin(10, 10, 10, 10)
  )
p1.timekillcurve.plot
```

## 9.3 Total number of tracked cells plot

```{r}


# Tracked value (example)
tracked_value <- unique(Tracking_LCF.corr$Trk_Tot.N)

# Colorbar data
legend_df <- tibble(
  y = seq(0, 12000, length.out = 500),
  x = 1
)

p2.n.trackedcells <- ggplot(legend_df, aes(x = x, y = y, fill = y)) +
  geom_tile(width = 1) +

  # Line for tracked value (black)
  geom_segment(
    aes(x = 1.05, xend = 1.5, y = tracked_value, yend = tracked_value),
    color = "navyblue",
    linewidth = 1
  ) +
  annotate("text", x = 1.51, y = tracked_value,
           label = tracked_value,
           hjust = 0,
           size = 4,
           color = "navyblue") +

  # Line for threshold (grey)
  geom_segment(
    aes(x = 1.05, xend = 1.5, y = 1000, yend = 1000),
    color = "black",
    linewidth = 1
  ) +
  annotate("text", x = 1.51, y = 1000,
           label = "Threshold",
           hjust = 0,
           size = 4,
           color = "black") +

  scale_y_continuous(
    breaks = seq(0, 12000, by = 1000),
    limits = c(0, 12000),
    expand = c(0, 0),
    name = "Number of tracked cells"
  ) +

  scale_fill_gradientn(
    colors = wes_palette("Zissou1", 100, type = "continuous"),
    guide = "none",
    limits = c(0, 12000)
  ) +

  coord_fixed(ratio = 0.0015, clip = "off") +
  theme_pubr() +
  theme(
    axis.title.y = element_text(size = 12, margin = margin(r = 10)),
    axis.text.y = element_text(size = 10),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    panel.grid = element_blank(),
    panel.border = element_blank(),
    plot.margin = margin(5, 50, 5, 5)
  )

p2.n.trackedcells

```

## 9.4 psudoGrowth plot

```{r}
psudoGrowth.plot <- psudoGrowthFeature.2.PLOT %>%
  mutate(log_psudoGrowth = log10(psudoGrowth_totObjArea_corr.nSCVS)) %>%
  filter(Time_Hrs >= 12 & Time_Hrs <= 72)

p3.psudoGrowth.plot <- ggplot(psudoGrowth.plot, aes(x = Time_Hrs,
                                          y = log_psudoGrowth)) +
  geom_line(linewidth = 0.5, color = "steelblue") +
  geom_point(size = 3, stroke = 0, color = "steelblue") +

  geom_hline(yintercept = 0.5,
             linetype = "dotted",
             alpha = 0.5,
             color = "black",
             linewidth = 0.4) +
  annotate("text", x = 36, y = 2,
             label = "change in area",
             size = 7, hjust = 0.5)+

  annotate("text", x = 12, y = 0.55,  # centered over x-axis, slightly above line
           label = "threshold",
           size = 3, hjust = 0.5, color = "black") +

  scale_x_continuous(
    limits = c(12, 72),
    breaks = seq(12, 72, by = 12),
    labels = paste0(seq(12, 72, by = 12))
  ) +

  scale_y_continuous(
    limits = c(0, 2),
    breaks = seq(0, 2, by = 0.5),
    name = "log10 (change in object area)"
  ) +

  labs(
       x = "Time (hrs)") +
  theme_pubr()


```



## 9.5 Exporting all plots

```{r}
# Combine top row with size ratio (larger left, smaller right)
top_row <- p1.timekillcurve.plot + p2.n.trackedcells + 
  plot_layout(ncol = 2, widths = c(4, 0.2))  # left 3x wider than right

# Stack with bottom plot (equal full width)
final_layout <- top_row / p3.psudoGrowth.plot + 
  plot_layout(heights = c(3, 1))  # top row 2x taller than bottom

# Save or display
final_layout

# PLOTTING TIME KILL CURVES
plot.filename <- paste(info.wd,
                       paste("/",
                         info.expID,
                         "_",
                   info.well,
                   "_Results/",
                   sep=""),
                       info.expID,
                   "_",
                       info.well,
                       "_Results.plot.pdf", sep = "")


# Export as A4 PDF
ggsave(plot.filename, plot = final_layout,
       width = 8.27, height = 11.69, units = "in")  # A4 size
```
```{r}
#Houskepeing
rm(final_layout,
   psudoGrowth.plot,
   psudoGrowthFeature.2.PLOT,
   legend_df,
   p1.timekillcurve.plot,
   p2.n.trackedcells,
   p3.psudoGrowth.plot,
   top_row,
   vline.df)
```

# Export
```{r}
# Exporting time kill curve data
export.filename <- paste(info.wd,
                       paste("/",
                         info.expID,
                         "_",
                   info.well,
                   "_Results/",
                   sep=""),
                       info.expID,
                   "_",
                       info.well,
                       "_TimeKillCurve_data.csv", sep = "")

export.lcf.df <- interpol.concatenated.df %>%
  select(ExpID,
         Well_coordinate,
         Time_Hrs,
         LC.fraction)%>%
  arrange(Time_Hrs)

write.csv(export.lcf.df ,export.filename,
          row.names = FALSE)

rm(export.lcf.df,
   export.filename)

# Exporting other features (AUC, psudo growth amd total number of tracked cells)

features.df <- data.frame( 
  ExpID = info.expID,
  Well_coordinate = info.well,
  AUC.0.to.72h = max(Killing.Features.df.2auc$KF.2.auc.sum), # will be the largest AUC
  Total.N.tracked.cells = tracked_value,
  psudoGrowth_evalaution = psudoGrowth.feature.df$psudoGrowth_evaluation )

export.filename <- paste(info.wd,
                       paste("/",
                         info.expID,
                         "_",
                   info.well,
                   "_Results/",
                   sep=""),
                       info.expID,
                   "_",
                       info.well,
                       "_ASCTfeatures.csv", sep = "")

write.csv(features.df ,export.filename,
          row.names = FALSE)


```


# --- Session info ---
```{r}
sessionInfo()
```



```{r}

```

